---
description: "Structured HITL test scenarios for the monocoque-agent-rc approval workflow."
---

# HITL Test Scenarios

Each scenario tests a specific aspect of the Slack-mediated approval workflow.
The operator's expected action is stated in **bold**.

---

## Scenario 1: Heartbeat Baseline

**Purpose:** Confirm MCP connectivity and active session before testing Slack paths.

**Steps:**
1. Call `heartbeat` with `status_message: "HITL test: connectivity check"`
2. Verify response contains `acknowledged: true`

**Expected:** `acknowledged: true` returned, status message posted to Slack channel.

---

## Scenario 2: Remote Log Delivery

**Purpose:** Verify that `remote_log` messages appear in the Slack channel with correct formatting.

**Steps:**
1. Call `remote_log` with `message: "HITL test: info level message"`, `level: "info"`
2. Call `remote_log` with `message: "HITL test: warning level message"`, `level: "warning"`
3. Call `remote_log` with `message: "HITL test: success level message"`, `level: "success"`
4. Verify each call returns successfully (no error)

**Expected:** Three messages appear in Slack with distinct visual formatting per level. Agent verifies no errors returned.

**Operator validates:**
- [ ] Info message appeared with neutral formatting
- [ ] Warning message appeared with warning indicator
- [ ] Success message appeared with success indicator

---

## Scenario 3: Auto-Approve Policy Check

**Purpose:** Baseline the workspace's auto-approve configuration.

**Steps:**
1. Call `check_auto_approve` with `tool_name: "accept_diff"`, `context: { "file_path": "logs/hitl-test-output.txt", "risk_level": "low" }`
2. Record whether `auto_approved` is `true` or `false`
3. Call `check_auto_approve` with `tool_name: "accept_diff"`, `context: { "file_path": "src/main.rs", "risk_level": "critical" }`
4. Record whether `auto_approved` is `true` or `false`

**Expected:** Results depend on workspace policy. Record both values — this establishes the baseline. Typically, `logs/` paths may be auto-approved while `src/` paths with critical risk are not.

---

## Scenario 4: Approval — Happy Path (Approve)

**Purpose:** Full approval round-trip. Operator sees Block Kit message, taps Approve, diff is applied.

**Steps:**
1. Call `ask_approval` with:
   - `title`: `"HITL Test: Create test fixture file"`
   - `diff`: `"# HITL Test Fixture\nGenerated by HITL test suite.\n"`
   - `file_path`: `"tests/fixtures/hitl-test-file.txt"`
   - `description`: `"HITL TEST: Please APPROVE this proposal. This creates a harmless test fixture."`
   - `risk_level`: `"high"`
2. **Operator action: APPROVE the proposal in Slack**
3. Verify response `status` is `"approved"` and `request_id` is a non-empty string
4. Call `accept_diff` with the returned `request_id`
5. Verify response `status` is `"applied"`
6. Verify the file `tests/fixtures/hitl-test-file.txt` exists on disk (use terminal: `Test-Path tests/fixtures/hitl-test-file.txt`)

**Expected:** Approved, file written to `tests/fixtures/hitl-test-file.txt`.

**Operator validates:**
- [ ] Block Kit message appeared with title, diff preview, and Approve/Reject buttons
- [ ] Buttons were replaced with approved status after clicking Approve
- [ ] High risk level was visually indicated

---

## Scenario 5: Rejection — Happy Path (Reject)

**Purpose:** Verify rejection flow. Operator taps Reject, agent receives rejection with reason.

**Steps:**
1. Call `ask_approval` with:
   - `title`: `"HITL Test: Intentionally rejected change"`
   - `diff`: `"+this line should never be written\n"`
   - `file_path`: `"tests/fixtures/hitl-rejected-file.txt"`
   - `description`: `"HITL TEST: Please REJECT this proposal. Type a reason like 'testing rejection flow'."`
   - `risk_level`: `"low"`
2. **Operator action: REJECT the proposal in Slack, providing a reason**
3. Verify response `status` is `"rejected"`
4. Verify response contains a `reason` field
5. Do NOT call `accept_diff` — the change was rejected
6. Verify `tests/fixtures/hitl-rejected-file.txt` does NOT exist on disk

**Expected:** Rejected with reason, no file written.

**Operator validates:**
- [ ] Rejection reason input was available
- [ ] Buttons were replaced with rejected status in Slack

---

## Scenario 6: Forward Prompt — Operator Question

**Purpose:** Test bidirectional communication. Agent asks operator a question, operator responds.

**Steps:**
1. Call `forward_prompt` with:
   - `prompt_text`: `"HITL TEST: What is your favorite color? (Reply with any answer to validate the prompt flow.)"`
2. **Operator action: Reply with any answer in Slack**
3. Verify the response contains the operator's answer text (non-empty string)

**Expected:** Operator's reply text is returned to the agent.

**Operator validates:**
- [ ] Question appeared in Slack with a reply mechanism
- [ ] Reply was straightforward to submit

---

## Scenario 7: Wait for Instruction — Operator-Initiated

**Purpose:** Test the passive wait mode where the agent blocks until the operator sends a command.

**Steps:**
1. Call `remote_log` with `message: "[TEST] About to call wait_for_instruction. Please send any message in Slack within 60 seconds."`, `level: "info"`
2. Call `wait_for_instruction` with `message: "HITL TEST: Agent is waiting for your instruction."`, `timeout_seconds: 120`
3. **Operator action: Send any message or command in the Slack channel**
4. Verify the response contains the operator's instruction text

**Expected:** Operator's message is returned as the instruction.

**Operator validates:**
- [ ] Waiting status message appeared in Slack
- [ ] Sending a message resolved the wait

---

## Scenario 8: Operational Mode Toggle

**Purpose:** Verify mode changes are communicated via Slack.

**Steps:**
1. Call `set_operational_mode` with `mode: "local"`
2. Verify response confirms mode changed to `local`
3. Call `set_operational_mode` with `mode: "hybrid"`
4. Verify response confirms mode changed to `hybrid`
5. Call `set_operational_mode` with `mode: "remote"` (restore default)
6. Verify response confirms mode changed back to `remote`

**Expected:** All three mode transitions succeed. Slack notifications sent for each change.

**Operator validates:**
- [ ] Slack channel received notification for each mode change
- [ ] Notifications clearly indicate the old → new mode

---

## Scenario 9: State Recovery

**Purpose:** Verify `recover_state` returns meaningful session state.

**Steps:**
1. Call `recover_state` with no arguments
2. Verify response contains structured state data (e.g., `status: "clean"` or session details)

**Expected:** Response contains valid JSON with a `status` field.

---

## Scenario 10: Double-Submission Prevention

**Purpose:** Verify that an already-consumed approval cannot be replayed.

**Steps:**
1. Call `ask_approval` with:
   - `title`: `"HITL Test: Double-submission test"`
   - `diff`: `"+double submit test line\n"`
   - `file_path`: `"tests/fixtures/hitl-double-submit.txt"`
   - `description`: `"HITL TEST: Please APPROVE this proposal."`
   - `risk_level`: `"low"`
2. **Operator action: APPROVE the proposal**
3. Call `accept_diff` with the returned `request_id`
4. Verify first `accept_diff` succeeds with `status: "applied"`
5. Call `accept_diff` again with the **same** `request_id`
6. Verify second `accept_diff` returns an error (e.g., `AlreadyConsumed` or similar)

**Expected:** First apply succeeds, second apply fails with a clear error.

---

## Scenario 11: Critical Risk Visual Indicator

**Purpose:** Verify that `risk_level: "critical"` renders differently in Slack.

**Steps:**
1. Call `ask_approval` with:
   - `title`: `"HITL Test: Critical risk visual check"`
   - `diff`: `"+# CRITICAL CHANGE — this is a visual test\n"`
   - `file_path`: `"persistence/schema.rs"`
   - `description`: `"HITL TEST: Please APPROVE. Verify that this message looks visually different from low-risk proposals (red warning, danger emoji, etc.)."`
   - `risk_level`: `"critical"`
2. **Operator action: APPROVE after visually confirming the risk indicator**
3. Call `accept_diff` with the returned `request_id`

**Expected:** Approved. Operator confirms critical-risk visual treatment.

**Operator validates:**
- [ ] Message had distinct visual treatment for critical risk (different from Scenario 4's high risk)
- [ ] Diff preview was rendered correctly
- [ ] Risk level was clearly communicated

---

## Scenario 12: Cleanup

**Purpose:** Remove test artifacts created during the suite.

**Steps:**
1. Use terminal to list test fixture files: `Get-ChildItem tests/fixtures/hitl-* -ErrorAction SilentlyContinue`
2. For each file found, call `ask_approval` with:
   - `title`: `"HITL Test: Cleanup — delete {filename}"`
   - `diff`: Unified diff showing file deletion
   - `file_path`: The file path
   - `description`: `"HITL TEST: Please APPROVE to clean up test artifacts."`
   - `risk_level`: `"low"`
3. **Operator action: APPROVE each cleanup proposal**
4. Call `accept_diff` for each approved cleanup
5. Verify all `hitl-*` files have been removed from `tests/fixtures/`

**Expected:** All test artifacts cleaned up.

**Note:** If no files were created (all prior approval scenarios were rejected or failed), skip this scenario and mark as PASS (nothing to clean).
